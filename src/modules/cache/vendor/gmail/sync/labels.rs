// Copyright Â© 2025 rustmailer.com
// Licensed under RustMailer License Agreement v1.0
// Unauthorized copying, modification, or distribution is prohibited.

use itertools::Itertools;
use native_db::*;
use native_model::{native_model, Model};
use poem_openapi::Object;
use serde::{Deserialize, Serialize};

use crate::{
    modules::{
        cache::imap::mailbox::MailBox,
        database::{
            async_find_impl, batch_delete_impl, batch_insert_impl, delete_impl,
            filter_by_secondary_key_impl, insert_impl, manager::DB_MANAGER, upsert_impl,
        },
        error::{code::ErrorCode, RustMailerResult},
    },
    raise_error, utc_now,
};

#[derive(Clone, Debug, Default, Eq, PartialEq, Deserialize, Serialize, Object)]
#[native_model(id = 7, version = 1)]
#[native_db]
pub struct GmailLabels {
    /// This `id` **must be a hash value constructed from both `account_id` and `label_id`**,
    /// ensuring global uniqueness across all accounts and labels.
    #[primary_key]
    pub id: u64,
    #[secondary_key]
    pub account_id: u64,
    pub name: String,
    pub exists: u32,
    pub unseen: u32,
    pub label_id: String,
}

impl GmailLabels {
    pub async fn save(&self) -> RustMailerResult<()> {
        insert_impl(DB_MANAGER.envelope_db(), self.to_owned()).await
    }

    pub async fn upsert(label: GmailLabels) -> RustMailerResult<()> {
        upsert_impl(DB_MANAGER.envelope_db(), label).await
    }

    pub async fn batch_insert(labels: &[GmailLabels]) -> RustMailerResult<()> {
        batch_insert_impl(DB_MANAGER.envelope_db(), labels.to_vec()).await
    }

    pub async fn delete(id: u64) -> RustMailerResult<()> {
        delete_impl(DB_MANAGER.envelope_db(), move |rw| {
            rw.get()
                .primary::<GmailLabels>(id)
                .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                .ok_or_else(|| raise_error!("label missing".into(), ErrorCode::InternalError))
        })
        .await
    }

    pub async fn list_all(account_id: u64) -> RustMailerResult<Vec<GmailLabels>> {
        filter_by_secondary_key_impl(
            DB_MANAGER.envelope_db(),
            GmailLabelsKey::account_id,
            account_id,
        )
        .await
    }

    pub async fn batch_delete(labels: Vec<GmailLabels>) -> RustMailerResult<()> {
        batch_delete_impl(DB_MANAGER.envelope_db(), move |rw| {
            let mut to_deleted = Vec::new();
            for label in labels {
                let retrived = rw
                    .get()
                    .primary::<GmailLabels>(label.id)
                    .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?;
                if let Some(retrived) = retrived {
                    to_deleted.push(retrived);
                }
            }
            Ok(to_deleted)
        })
        .await?;
        Ok(())
    }
}

impl From<GmailLabels> for MailBox {
    fn from(value: GmailLabels) -> Self {
        Self {
            id: value.id,
            account_id: value.account_id,
            name: value.name,
            delimiter: Some("/".into()),
            attributes: vec![],
            flags: vec![],
            exists: value.exists,
            unseen: Some(value.unseen),
            permanent_flags: vec![],
            uid_next: None,
            uid_validity: None,
            highest_modseq: None,
        }
    }
}

#[derive(Clone, Debug, Default, Eq, PartialEq, Deserialize, Serialize, Object)]
#[native_model(id = 8, version = 1)]
#[native_db]
pub struct GmailCheckPoint {
    /// Primary key for the checkpoint.
    /// Generated by hashing the combination of `account_id` and `label_id` (as a string).
    /// Uniquely identifies the sync state of a specific label for a specific account.
    #[primary_key]
    pub id: u64,

    /// The Gmail account ID this checkpoint belongs to.
    #[secondary_key]
    pub account_id: u64,

    /// The latest Gmail `historyId` for incremental synchronization.
    /// Used as `startHistoryId` in the next Gmail History API call.
    pub history_id: String,

    /// Creation timestamp in UNIX epoch milliseconds.
    /// Records when this checkpoint was initially created.
    pub created_at: i64,

    /// Last update timestamp in UNIX epoch milliseconds.
    /// Records the most recent time this checkpoint was updated.
    pub updated_at: i64,
}

impl GmailCheckPoint {
    pub async fn get(id: u64) -> RustMailerResult<GmailCheckPoint> {
        let entity = async_find_impl(DB_MANAGER.envelope_db(), id).await?;
        entity.ok_or_else(|| {
            raise_error!(
                format!("GmailCheckPoint not found for id={}", id),
                ErrorCode::ResourceNotFound
            )
        })
    }

    pub fn new(account_id: u64, label_id: u64, max_history_id: String) -> Self {
        Self {
            id: label_id,
            account_id,
            history_id: max_history_id,
            created_at: utc_now!(),
            updated_at: utc_now!(),
        }
    }
    // Upsert is used here to overwrite the existing record
    pub async fn save(&self) -> RustMailerResult<()> {
        upsert_impl(DB_MANAGER.envelope_db(), self.to_owned()).await
    }

    pub async fn list_all(account_id: u64) -> RustMailerResult<Vec<GmailLabels>> {
        filter_by_secondary_key_impl(
            DB_MANAGER.envelope_db(),
            GmailLabelsKey::account_id,
            account_id,
        )
        .await
    }

    pub async fn clean(account_id: u64) -> RustMailerResult<()> {
        batch_delete_impl(DB_MANAGER.envelope_db(), move |rw| {
            let to_delete: Vec<GmailCheckPoint> = rw
                .scan()
                .secondary(GmailCheckPointKey::account_id)
                .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                .start_with(account_id)
                .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?
                .try_collect()
                .map_err(|e| raise_error!(format!("{:#?}", e), ErrorCode::InternalError))?;
            Ok(to_delete)
        })
        .await?;
        Ok(())
    }
}
